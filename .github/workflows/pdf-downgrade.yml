name: PDF → PDF 1.4 (multi-engine, logs, autocommit)

concurrency:
  group: pdf-downgrade-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      path:
        description: 'Opcjonalna ścieżka do jednego PDF-a (np. input/plik.pdf). Pusta = skanuj input/, potem całe repo.'
        required: false
        default: ''
      pdfsettings:
        description: 'Profil Ghostscript: /prepress, /printer, /ebook, /screen'
        required: false
        default: '/prepress'
      allow_raster_fallback:
        description: 'Zezwól na fallback rastrowy (true/false)'
        required: false
        default: 'true'
      raster_dpi:
        description: 'DPI dla fallbacku rastrowego (np. 300)'
        required: false
        default: '300'
  push:
    paths:
      - "input/**.pdf"
      - "input/**.PDF"

jobs:
  convert:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (with LFS)
        uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0

      - name: Show repo tree & find PDFs (debug)
        run: |
          echo "== CWD =="; pwd
          echo "== Repo tree =="; ls -lahR || true
          echo "== PDFs in input/ (any case) =="
          find input -type f \( -iname "*.pdf" -o -iname "*.PDF" \) -print || true

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ghostscript qpdf mupdf-tools poppler-utils imagemagick
          gs -v || true
          qpdf --version || true
          mutool -v || true
          pdftocairo -v || true
          convert -version || true

      - name: Convert PDFs (GS → QPDF+GS → MuPDF+GS → MuPDF convert → Raster → ImageMagick)
        shell: bash
        env:
          PDFSETTINGS: ${{ github.event.inputs.pdfsettings || '/prepress' }}
          ALLOW_RASTER: ${{ github.event.inputs.allow_raster_fallback || 'true' }}
          INPUT_PATH: ${{ github.event.inputs.path || '' }}
          RASTER_DPI: ${{ github.event.inputs.raster_dpi || '300' }}
        run: |
          set -uo pipefail    # bez -e, żeby nie przerwać całego kroku na 1 błędzie
          mkdir -p output logs

          echo "PDFSETTINGS=${PDFSETTINGS}"
          echo "ALLOW_RASTER=${ALLOW_RASTER}"
          echo "INPUT_PATH=${INPUT_PATH}"
          echo "RASTER_DPI=${RASTER_DPI}"

          # Zbierz pliki wejściowe
          declare -a files=()
          if [[ -n "$INPUT_PATH" ]]; then
            files=( "$INPUT_PATH" )
          else
            mapfile -t files < <(find input -type f \( -iname "*.pdf" -o -iname "*.PDF" \) -print 2>/dev/null || true)
            if (( ${#files[@]} == 0 )); then
              echo "Brak w input/. Skanuję całe repo (bez .git oraz output/)..."
              mapfile -t files < <(find . -type f \( -iname "*.pdf" -o -iname "*.PDF" \) ! -path "./.git/*" ! -path "./output/*" -print)
            fi
          fi

          if (( ${#files[@]} == 0 )); then
            echo "ERROR: Nie znaleziono żadnych PDF-ów."
            exit 66
          fi

          success_count=0
          fail_count=0

          convert_one() {
            local f="$1"
            local base stem out log tmp1 tmp2 tmp3 out_raster out_im
            base="$(basename "$f")"; stem="${base%.*}"
            out="output/${stem}_PDF14.pdf"
            log="logs/${stem}.log"

            echo "=== Przetwarzam: $f ===" | tee "$log"

            # 1) Ghostscript (bezpośrednio)
            if gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dBATCH \
                  -dPDFSETTINGS="${PDFSETTINGS}" \
                  -sOutputFile="$out" "$f" >>"$log" 2>&1; then
              echo "OK: Ghostscript" | tee -a "$log"
              return 0
            else
              echo "GS (bezpośrednio) nie powiodło się." | tee -a "$log"
            fi

            # 2) qpdf → Ghostscript
            tmp1="$(mktemp --suffix=.pdf)" || tmp1="$(mktemp)"
            if qpdf --linearize "$f" "$tmp1" >>"$log" 2>&1 && \
               gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dBATCH \
                  -dPDFSETTINGS="${PDFSETTINGS}" \
                  -sOutputFile="$out" "$tmp1" >>"$log" 2>&1; then
              echo "OK: qpdf + GS" | tee -a "$log"
              rm -f "$tmp1"
              return 0
            else
              echo "qpdf+GS nie powiodło się." | tee -a "$log"
              rm -f "$tmp1" || true
            fi

            # 3) MuPDF (mutool clean) → Ghostscript
            tmp2="$(mktemp --suffix=.pdf)" || tmp2="$(mktemp)"
            if mutool clean -gg -d "$f" "$tmp2" >>"$log" 2>&1 && \
               gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dBATCH \
                  -dPDFSETTINGS="${PDFSETTINGS}" \
                  -sOutputFile="$out" "$tmp2" >>"$log" 2>&1; then
              echo "OK: MuPDF + GS" | tee -a "$log"
              rm -f "$tmp2"
              return 0
            else
              echo "MuPDF+GS nie powiodło się." | tee -a "$log"
              rm -f "$tmp2" || true
            fi

            # 4) MuPDF convert (bez GS): przepakowanie do nowego PDF
            tmp3="$(mktemp --suffix=.pdf)" || tmp3="$(mktemp)"
            if mutool convert -o "$tmp3" -F pdf "$f" >>"$log" 2>&1; then
              # spróbuj jeszcze "dowieźć" do 1.4 Ghostscriptem
              if gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dNOPAUSE -dBATCH \
                    -dPDFSETTINGS="${PDFSETTINGS}" \
                    -sOutputFile="$out" "$tmp3" >>"$log" 2>&1; then
                echo "OK: MuPDF convert → GS" | tee -a "$log"
                rm -f "$tmp3"
                return 0
              fi
              # gdyby GS padł, weź czysty wynik MuPDF
              mv "$tmp3" "$out"
              echo "OK: MuPDF convert (bez GS)" | tee -a "$log"
              return 0
            else
              echo "MuPDF convert nie powiódł się." | tee -a "$log"
              rm -f "$tmp3" || true
            fi

            # 5) Raster fallback (pdftocairo)
            if [[ "${ALLOW_RASTER}" == "true" ]]; then
              out_raster="output/${stem}_RASTER_PDF14.pdf"
              if pdftocairo -pdf -r "${RASTER_DPI}" "$f" "output/${stem}_RASTER" >>"$log" 2>&1; then
                mv "output/${stem}_RASTER.pdf" "$out_raster"
                echo "OK: Raster fallback (pdftocairo ${RASTER_DPI} DPI)" | tee -a "$log"
                return 0
              else
                echo "Raster fallback (pdftocairo) nie powiódł się." | tee -a "$log"
              fi
            else
              echo "Raster fallback wyłączony." | tee -a "$log"
            fi

            # 6) Ostateczny fallback: ImageMagick (może pogorszyć kolory/teksty)
            out_im="output/${stem}_IMAGEMAGICK_PDF14.pdf"
            if convert -density "${RASTER_DPI}" "$f" -units PixelsPerInch -compress Zip "$out_im" >>"$log" 2>&1; then
              echo "OK: ImageMagick fallback (${RASTER_DPI} DPI)" | tee -a "$log"
              return 0
            else
              echo "ImageMagick fallback nie powiódł się." | tee -a "$log"
            fi

            echo "FAIL: wszystkie metody zawiodły dla $f" | tee -a "$log"
            return 1
          }

          # Pętla po plikach — kontynuujemy mimo błędów
          for f in "${files[@]}"; do
            if convert_one "$f"; then
              ((success_count++))
            else
              ((fail_count++))
            fi
          done

          echo "== Podsumowanie =="
          echo "Sukcesy: $success_count"
          echo "Niepowodzenia: $fail_count"

          # Jeśli absolutnie żaden się nie udał — sygnalizuj błąd
          if (( success_count == 0 )); then
            exit 1
          fi

      - name: List outputs
        run: |
          echo "== output =="; ls -lah output || true
          echo "== logs =="; ls -lah logs || true

      - name: Upload artifacts (PDFs + logs)
        uses: actions/upload-artifact@v4
        with:
          name: converted-pdfs-and-logs
          path: |
            output
            logs
          if-no-files-found: warn
          retention-days: 14

      - name: Print logs on failure
        if: failure()
        run: |
          echo "=== SHORT LOG DUMP (first 200 lines each) ==="
          for f in logs/*.log; do
            echo "----- $f -----"
            sed -n '1,200p' "$f" || true
          done

      - name: Determine target branch
        id: branch
        run: |
          echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}" >> "$GITHUB_OUTPUT"
          echo "Using branch: ${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"

      - name: Commit & push outputs back to repo (robust)
        if: success()
        continue-on-error: true
        env:
          BRANCH: ${{ steps.branch.outputs.branch }}
        run: |
          if [ -z "$(ls -A output 2>/dev/null)" ]; then
            echo "No files in output/, nothing to commit."
            exit 0
          fi

          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin "$BRANCH" || true
          git checkout -B "$BRANCH" "origin/$BRANCH" 2>/dev/null || git checkout -B "$BRANCH"

          git add output || true
          git commit -m "Add converted PDFs ($(date -u +'%Y-%m-%d %H:%M:%S') UTC)" || echo "No changes to commit."

          git pull --ff-only origin "$BRANCH" || echo "::warning ::Pull failed (ff-only). Continuing."
          git push origin "HEAD:$BRANCH" || echo "::warning ::Push failed (protected branch or permissions)."
